<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoAI 3D Globe - Global Building Detection</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #0a0a0a 0%, #000000 100%);
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        .globe-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 20, 40, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(64, 255, 218, 0.2);
            border-radius: 12px;
            padding: 20px;
            min-width: 300px;
        }

        .controls-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 20, 40, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(64, 255, 218, 0.2);
            border-radius: 12px;
            padding: 20px;
            min-width: 250px;
        }

        .bottom-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 20, 40, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(64, 255, 218, 0.2);
            border-radius: 12px;
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #64ffda 0%, #00d4ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(100, 255, 218, 0.1);
        }

        .metric:last-child {
            border-bottom: none;
        }

        .metric-value {
            color: #64ffda;
            font-weight: 600;
        }

        .control-button {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #64ffda 0%, #00d4ff 100%);
            color: #0c0c1f;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(100, 255, 218, 0.3);
        }

        .control-button.secondary {
            background: transparent;
            color: #64ffda;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }

        .location-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .location-item {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(100, 255, 218, 0.1);
            border-radius: 6px;
            margin-bottom: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .location-item:hover {
            background: rgba(100, 255, 218, 0.1);
            border-color: #64ffda;
        }

        .location-name {
            font-weight: 600;
            color: #64ffda;
        }

        .location-stats {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .info-section {
            text-align: center;
        }

        .info-title {
            font-weight: 600;
            margin-bottom: 5px;
            color: #64ffda;
        }

        .info-value {
            font-size: 1.2rem;
            font-weight: 800;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 15px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s infinite;
        }

        .status-offline {
            background: #ef4444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
    </style>
</head>
<body>
    <div class="globe-container" id="globe-container">
        <!-- UI Overlay -->
        <div class="ui-overlay">
            <div class="logo">üåç Global Building AI</div>
            
            <div class="metric">
                <span>Total Buildings</span>
                <span class="metric-value" id="total-buildings">0</span>
            </div>
            
            <div class="metric">
                <span>Active Regions</span>
                <span class="metric-value" id="active-regions">0</span>
            </div>
            
            <div class="metric">
                <span>Processing Speed</span>
                <span class="metric-value" id="processing-speed">0 img/s</span>
            </div>
            
            <div class="metric">
                <span>Global Coverage</span>
                <span class="metric-value" id="coverage">0%</span>
            </div>

            <div class="connection-status">
                <div class="status-dot" id="connection-status"></div>
                <span>Live Connection</span>
            </div>
            
            <div class="location-list" id="location-list">
                <!-- Location items will be populated here -->
            </div>
        </div>

        <!-- Controls Overlay -->
        <div class="controls-overlay">
            <h3 style="color: #64ffda; margin-bottom: 15px;">üéÆ Globe Controls</h3>
            
            <button class="control-button" onclick="rotateToRegion('north-america')">
                üá∫üá∏ North America
            </button>
            <button class="control-button" onclick="rotateToRegion('europe')">
                üá™üá∫ Europe
            </button>
            <button class="control-button" onclick="rotateToRegion('asia')">
                üá®üá≥ Asia Pacific
            </button>
            <button class="control-button" onclick="rotateToRegion('africa')">
                üåç Africa
            </button>
            
            <button class="control-button secondary" onclick="toggleAnimation()">
                ‚èØÔ∏è Toggle Rotation
            </button>
            <button class="control-button secondary" onclick="resetView()">
                üîÑ Reset View
            </button>
            <button class="control-button secondary" onclick="toggleWireframe()">
                üî≤ Wireframe Mode
            </button>
        </div>

        <!-- Bottom Info -->
        <div class="bottom-info">
            <div class="info-section">
                <div class="info-title">Cities Analyzed</div>
                <div class="info-value" id="cities-count">127</div>
            </div>
            <div class="info-section">
                <div class="info-title">Accuracy Rate</div>
                <div class="info-value" id="accuracy-rate">94.2%</div>
            </div>
            <div class="info-section">
                <div class="info-title">Processing Queue</div>
                <div class="info-value" id="queue-length">0</div>
            </div>
            <div class="info-section">
                <div class="info-title">Data Points</div>
                <div class="info-value" id="data-points">2.1M</div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let globeGroup, markersGroup;
        let isRotating = true;
        let isWireframe = false;
        let websocket = null;
        
        // Globe properties
        const GLOBE_RADIUS = 50;
        const MARKER_HEIGHT = 2;
        
        // Configuration
        const API_BASE = 'http://127.0.0.1:8002';
        const WS_URL = 'ws://127.0.0.1:8002/ws';
        
        // Global statistics
        const globalStats = {
            totalBuildings: 0,
            activeRegions: 0,
            processingSpeed: 0,
            coverage: 0,
            citiesCount: 127,
            accuracyRate: 94.2,
            queueLength: 0,
            dataPoints: 2100000
        };

        // Major cities with coordinates
        const majorCities = [
            { name: "New York", lat: 40.7128, lng: -74.0060, buildings: 45000, region: "north-america" },
            { name: "London", lat: 51.5074, lng: -0.1278, buildings: 38000, region: "europe" },
            { name: "Tokyo", lat: 35.6762, lng: 139.6503, buildings: 52000, region: "asia" },
            { name: "Sydney", lat: -33.8688, lng: 151.2093, buildings: 28000, region: "oceania" },
            { name: "Dubai", lat: 25.2048, lng: 55.2708, buildings: 31000, region: "asia" },
            { name: "S√£o Paulo", lat: -23.5505, lng: -46.6333, buildings: 41000, region: "south-america" },
            { name: "Mumbai", lat: 19.0760, lng: 72.8777, buildings: 39000, region: "asia" },
            { name: "Berlin", lat: 52.5200, lng: 13.4050, buildings: 29000, region: "europe" },
            { name: "Cairo", lat: 30.0444, lng: 31.2357, buildings: 33000, region: "africa" },
            { name: "Lagos", lat: 6.5244, lng: 3.3792, buildings: 27000, region: "africa" }
        ];

        // Initialize the globe
        document.addEventListener('DOMContentLoaded', function() {
            initializeGlobe();
            populateLocationList();
            connectWebSocket();
            startDataSimulation();
        });

        function initializeGlobe() {
            const container = document.getElementById('globe-container');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 120);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 80;
            controls.maxDistance = 200;
            
            // Create globe
            createGlobe();
            
            // Create markers
            createCityMarkers();
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0x64ffda, 0.8);
            directionalLight.position.set(100, 100, 50);
            scene.add(directionalLight);
            
            // Start animation
            animate();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        function createGlobe() {
            globeGroup = new THREE.Group();
            
            // Main globe sphere
            const globeGeometry = new THREE.SphereGeometry(GLOBE_RADIUS, 64, 32);
            
            // Create earth-like texture with procedural generation
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Create gradient for earth colors
            const gradient = ctx.createLinearGradient(0, 0, 1024, 512);
            gradient.addColorStop(0, '#1e3a5f');    // Deep ocean
            gradient.addColorStop(0.3, '#2e5a7f');  // Shallow water
            gradient.addColorStop(0.5, '#4a7c59');  // Coastal areas
            gradient.addColorStop(0.7, '#6b8e23');  // Land
            gradient.addColorStop(1, '#8fbc8f');    // Highlands
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1024, 512);
            
            // Add some noise for terrain variation
            const imageData = ctx.getImageData(0, 0, 1024, 512);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 30;
                data[i] = Math.max(0, Math.min(255, data[i] + noise));     // R
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise)); // G
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise)); // B
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            const globeTexture = new THREE.CanvasTexture(canvas);
            const globeMaterial = new THREE.MeshLambertMaterial({ 
                map: globeTexture,
                transparent: true,
                opacity: 0.9
            });
            
            const globe = new THREE.Mesh(globeGeometry, globeMaterial);
            globeGroup.add(globe);
            
            // Atmosphere glow
            const atmosphereGeometry = new THREE.SphereGeometry(GLOBE_RADIUS + 2, 64, 32);
            const atmosphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x64ffda,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            globeGroup.add(atmosphere);
            
            scene.add(globeGroup);
        }

        function createCityMarkers() {
            markersGroup = new THREE.Group();
            
            majorCities.forEach(city => {
                createCityMarker(city);
            });
            
            scene.add(markersGroup);
        }

        function createCityMarker(city) {
            // Convert lat/lng to 3D coordinates
            const phi = (90 - city.lat) * Math.PI / 180;
            const theta = (city.lng + 180) * Math.PI / 180;
            
            const x = -(GLOBE_RADIUS + MARKER_HEIGHT) * Math.sin(phi) * Math.cos(theta);
            const y = (GLOBE_RADIUS + MARKER_HEIGHT) * Math.cos(phi);
            const z = (GLOBE_RADIUS + MARKER_HEIGHT) * Math.sin(phi) * Math.sin(theta);
            
            // Create marker geometry
            const markerGeometry = new THREE.ConeGeometry(0.5, 3, 8);
            const markerMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x64ffda,
                transparent: true,
                opacity: 0.8
            });
            
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, y, z);
            marker.lookAt(new THREE.Vector3(x * 2, y * 2, z * 2));
            marker.userData = city;
            
            // Add pulsing animation
            marker.scale.setScalar(1 + Math.sin(Date.now() * 0.005 + city.lat) * 0.2);
            
            // Create city glow
            const glowGeometry = new THREE.SphereGeometry(1, 16, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x64ffda,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(marker.position);
            
            markersGroup.add(marker);
            markersGroup.add(glow);
            
            // Update global stats
            globalStats.totalBuildings += city.buildings;
        }

        function populateLocationList() {
            const locationList = document.getElementById('location-list');
            locationList.innerHTML = '';
            
            majorCities.forEach(city => {
                const locationItem = document.createElement('div');
                locationItem.className = 'location-item';
                locationItem.innerHTML = `
                    <div class="location-name">${city.name}</div>
                    <div class="location-stats">${city.buildings.toLocaleString()} buildings detected</div>
                `;
                
                locationItem.addEventListener('click', () => {
                    focusOnCity(city);
                });
                
                locationList.appendChild(locationItem);
            });
            
            globalStats.activeRegions = new Set(majorCities.map(city => city.region)).size;
            updateUI();
        }

        function focusOnCity(city) {
            const phi = (90 - city.lat) * Math.PI / 180;
            const theta = (city.lng + 180) * Math.PI / 180;
            
            const distance = 80;
            const x = -distance * Math.sin(phi) * Math.cos(theta);
            const y = distance * Math.cos(phi);
            const z = distance * Math.sin(phi) * Math.sin(theta);
            
            // Animate camera to city
            animateCameraTo(new THREE.Vector3(x, y, z), new THREE.Vector3(0, 0, 0));
        }

        function animateCameraTo(position, target) {
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            const duration = 2000;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = easeInOutCubic(progress);
                
                camera.position.lerpVectors(startPos, position, eased);
                controls.target.lerpVectors(startTarget, target, eased);
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Auto-rotation
            if (isRotating) {
                globeGroup.rotation.y += 0.002;
                markersGroup.rotation.y += 0.002;
            }
            
            // Animate markers
            markersGroup.children.forEach((marker, index) => {
                if (marker.geometry instanceof THREE.ConeGeometry) {
                    const scale = 1 + Math.sin(Date.now() * 0.003 + index) * 0.2;
                    marker.scale.setScalar(scale);
                }
            });
            
            controls.update();
            renderer.render(scene, camera);
        }

        // Control functions
        function rotateToRegion(region) {
            const regionCoords = {
                'north-america': { lat: 45, lng: -100 },
                'europe': { lat: 50, lng: 10 },
                'asia': { lat: 35, lng: 105 },
                'africa': { lat: 0, lng: 20 }
            };
            
            const coords = regionCoords[region];
            if (coords) {
                focusOnCity(coords);
            }
        }

        function toggleAnimation() {
            isRotating = !isRotating;
        }

        function resetView() {
            camera.position.set(0, 0, 120);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        function toggleWireframe() {
            isWireframe = !isWireframe;
            globeGroup.children.forEach(child => {
                if (child.material) {
                    child.material.wireframe = isWireframe;
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // WebSocket connection
        function connectWebSocket() {
            try {
                websocket = new WebSocket(WS_URL);
                
                websocket.onopen = function(event) {
                    console.log('WebSocket connected');
                    document.getElementById('connection-status').classList.remove('status-offline');
                    
                    // Send subscription message
                    websocket.send(JSON.stringify({
                        type: 'subscribe',
                        channels: ['job_progress', 'job_completed', 'building_detected']
                    }));
                };
                
                websocket.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                };
                
                websocket.onclose = function(event) {
                    console.log('WebSocket disconnected');
                    document.getElementById('connection-status').classList.add('status-offline');
                    
                    // Attempt to reconnect after 5 seconds
                    setTimeout(connectWebSocket, 5000);
                };
                
                websocket.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    document.getElementById('connection-status').classList.add('status-offline');
                };
                
            } catch (error) {
                console.log('WebSocket not available, using simulation mode');
                document.getElementById('connection-status').classList.add('status-offline');
            }
        }

        function handleWebSocketMessage(data) {
            switch (data.type) {
                case 'job_completed':
                    if (data.results && data.results.building_locations) {
                        addBuildingsToGlobe(data.results.building_locations);
                    }
                    break;
                    
                case 'job_progress':
                    globalStats.queueLength = Math.max(0, globalStats.queueLength);
                    updateUI();
                    break;
                    
                case 'building_detected':
                    addRandomBuilding();
                    break;
            }
        }

        function addBuildingsToGlobe(buildings) {
            buildings.forEach((building, index) => {
                setTimeout(() => {
                    // Convert building coordinates to globe position
                    const lat = (building.x / 100) * 180; // Convert to lat range
                    const lng = (building.z / 100) * 360; // Convert to lng range
                    
                    const phi = (90 - lat) * Math.PI / 180;
                    const theta = (lng + 180) * Math.PI / 180;
                    
                    const radius = GLOBE_RADIUS + 0.2;
                    const x = -radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.cos(phi);
                    const z = radius * Math.sin(phi) * Math.sin(theta);
                    
                    // Create small building marker
                    const buildingGeometry = new THREE.BoxGeometry(0.1, building.height * 0.1, 0.1);
                    const buildingMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(building.confidence * 0.3, 0.8, 0.6)
                    });
                    
                    const buildingMarker = new THREE.Mesh(buildingGeometry, buildingMaterial);
                    buildingMarker.position.set(x, y, z);
                    markersGroup.add(buildingMarker);
                    
                    globalStats.totalBuildings++;
                }, index * 50);
            });
            
            updateUI();
        }

        function addRandomBuilding() {
            // Add a random building to a random city
            const randomCity = majorCities[Math.floor(Math.random() * majorCities.length)];
            randomCity.buildings += Math.floor(Math.random() * 5) + 1;
            globalStats.totalBuildings += randomCity.buildings;
            updateUI();
        }

        function startDataSimulation() {
            setInterval(() => {
                // Simulate processing speed changes
                globalStats.processingSpeed = 0.5 + Math.random() * 2;
                globalStats.coverage = Math.min(100, globalStats.coverage + 0.1);
                globalStats.queueLength = Math.max(0, globalStats.queueLength + (Math.random() - 0.5) * 2);
                
                updateUI();
            }, 2000);
            
            // Occasionally add new buildings
            setInterval(() => {
                if (Math.random() < 0.3) {
                    addRandomBuilding();
                }
            }, 5000);
        }

        function updateUI() {
            document.getElementById('total-buildings').textContent = globalStats.totalBuildings.toLocaleString();
            document.getElementById('active-regions').textContent = globalStats.activeRegions;
            document.getElementById('processing-speed').textContent = globalStats.processingSpeed.toFixed(1) + ' img/s';
            document.getElementById('coverage').textContent = globalStats.coverage.toFixed(1) + '%';
            document.getElementById('cities-count').textContent = globalStats.citiesCount;
            document.getElementById('accuracy-rate').textContent = globalStats.accuracyRate.toFixed(1) + '%';
            document.getElementById('queue-length').textContent = Math.floor(globalStats.queueLength);
            document.getElementById('data-points').textContent = (globalStats.dataPoints / 1000000).toFixed(1) + 'M';
        }

        // Initialize UI
        updateUI();
    </script>
</body>
</html>
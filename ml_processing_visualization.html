<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoAI ML Processing Visualization - Neural Network Pipeline</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        .processing-container {
            display: grid;
            grid-template-areas: 
                "header header header"
                "pipeline canvas results"
                "controls canvas metrics";
            grid-template-columns: 300px 1fr 250px;
            grid-template-rows: 80px 1fr 200px;
            height: 100vh;
            gap: 15px;
            padding: 15px;
        }

        .header {
            grid-area: header;
            background: rgba(0, 20, 40, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(64, 255, 218, 0.2);
            border-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 25px;
        }

        .logo {
            font-size: 1.8rem;
            font-weight: 800;
            background: linear-gradient(135deg, #64ffda 0%, #00d4ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .processing-stats {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 800;
            color: #64ffda;
        }

        .stat-label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .pipeline-panel {
            grid-area: pipeline;
            background: rgba(0, 20, 40, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(64, 255, 218, 0.2);
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
        }

        .neural-canvas {
            grid-area: canvas;
            background: rgba(0, 20, 40, 0.4);
            border: 1px solid rgba(64, 255, 218, 0.2);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .results-panel {
            grid-area: results;
            background: rgba(0, 20, 40, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(64, 255, 218, 0.2);
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
        }

        .controls-panel {
            grid-area: controls;
            background: rgba(0, 20, 40, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(64, 255, 218, 0.2);
            border-radius: 12px;
            padding: 20px;
        }

        .metrics-panel {
            grid-area: metrics;
            background: rgba(0, 20, 40, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(64, 255, 218, 0.2);
            border-radius: 12px;
            padding: 20px;
        }

        .panel-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #64ffda;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .pipeline-stage {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(64, 255, 218, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
            position: relative;
        }

        .pipeline-stage.active {
            border-color: #64ffda;
            background: rgba(100, 255, 218, 0.1);
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.3);
        }

        .stage-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .stage-name {
            font-weight: 600;
            color: #ffffff;
        }

        .stage-progress {
            font-size: 0.9rem;
            color: #64ffda;
            font-weight: 600;
        }

        .stage-description {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #64ffda, #00d4ff);
            border-radius: 2px;
            transition: width 0.5s ease;
            width: 0%;
        }

        .layer-visualization {
            margin: 15px 0;
        }

        .layer-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .layer-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #64ffda;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
        }

        .layer-info {
            flex: 1;
        }

        .layer-name {
            font-size: 0.8rem;
            font-weight: 600;
            color: #ffffff;
        }

        .layer-details {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .layer-status {
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: 600;
        }

        .status-processing {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }

        .status-completed {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .status-waiting {
            background: rgba(107, 114, 128, 0.2);
            color: #9ca3af;
        }

        .control-button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #64ffda 0%, #00d4ff 100%);
            color: #0c0c1f;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(100, 255, 218, 0.3);
        }

        .control-button.secondary {
            background: transparent;
            color: #64ffda;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }

        .model-selector {
            margin-bottom: 15px;
        }

        .model-option {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(64, 255, 218, 0.2);
            border-radius: 6px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .model-option.active {
            background: rgba(100, 255, 218, 0.2);
            border-color: #64ffda;
        }

        .model-option:hover {
            background: rgba(100, 255, 218, 0.1);
        }

        .result-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(64, 255, 218, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .result-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 8px;
        }

        .result-confidence {
            font-size: 0.8rem;
            color: #64ffda;
            font-weight: 600;
        }

        .result-details {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(100, 255, 218, 0.1);
        }

        .metric-item:last-child {
            border-bottom: none;
        }

        .metric-value {
            color: #64ffda;
            font-weight: 600;
        }

        .neural-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .data-flow {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .flow-node {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #64ffda, #00d4ff);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            color: #0c0c1f;
        }

        .flow-arrow {
            color: #64ffda;
            font-size: 1.2rem;
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        @keyframes dataFlow {
            0% { transform: translateX(-100%); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateX(100%); opacity: 0; }
        }

        .scrollbar {
            scrollbar-width: thin;
            scrollbar-color: #64ffda rgba(255, 255, 255, 0.1);
        }

        .scrollbar::-webkit-scrollbar {
            width: 6px;
        }

        .scrollbar::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .scrollbar::-webkit-scrollbar-thumb {
            background: #64ffda;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="processing-container">
        <!-- Header -->
        <header class="header">
            <div class="logo">🧠 ML Processing Visualization</div>
            <div class="processing-stats">
                <div class="stat-item">
                    <div class="stat-value" id="active-models">3</div>
                    <div class="stat-label">Active Models</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="processing-queue">0</div>
                    <div class="stat-label">Queue Size</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="inference-speed">0.0ms</div>
                    <div class="stat-label">Inference Speed</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="gpu-utilization">0%</div>
                    <div class="stat-label">GPU Usage</div>
                </div>
            </div>
        </header>

        <!-- Pipeline Panel -->
        <section class="pipeline-panel scrollbar">
            <div class="panel-title">
                ⚙️ Processing Pipeline
            </div>

            <div class="pipeline-stage" id="stage-input">
                <div class="stage-header">
                    <div class="stage-name">📥 Input Processing</div>
                    <div class="stage-progress">0%</div>
                </div>
                <div class="stage-description">Image loading, validation, and preprocessing</div>
                <div class="progress-bar">
                    <div class="progress-fill"></div>
                </div>
                <div class="layer-visualization">
                    <div class="layer-row">
                        <div class="layer-icon">📄</div>
                        <div class="layer-info">
                            <div class="layer-name">Image Decoder</div>
                            <div class="layer-details">JPEG/PNG → RGB Array</div>
                        </div>
                        <div class="layer-status status-waiting">Waiting</div>
                    </div>
                    <div class="layer-row">
                        <div class="layer-icon">🔧</div>
                        <div class="layer-info">
                            <div class="layer-name">Normalization</div>
                            <div class="layer-details">Pixel value scaling</div>
                        </div>
                        <div class="layer-status status-waiting">Waiting</div>
                    </div>
                </div>
            </div>

            <div class="pipeline-stage" id="stage-preprocessing">
                <div class="stage-header">
                    <div class="stage-name">🔄 Preprocessing</div>
                    <div class="stage-progress">0%</div>
                </div>
                <div class="stage-description">Data augmentation and feature extraction</div>
                <div class="progress-bar">
                    <div class="progress-fill"></div>
                </div>
                <div class="layer-visualization">
                    <div class="layer-row">
                        <div class="layer-icon">📐</div>
                        <div class="layer-info">
                            <div class="layer-name">Resize & Crop</div>
                            <div class="layer-details">1024x1024 → 512x512</div>
                        </div>
                        <div class="layer-status status-waiting">Waiting</div>
                    </div>
                    <div class="layer-row">
                        <div class="layer-icon">🎨</div>
                        <div class="layer-info">
                            <div class="layer-name">Augmentation</div>
                            <div class="layer-details">Rotation, flip, contrast</div>
                        </div>
                        <div class="layer-status status-waiting">Waiting</div>
                    </div>
                </div>
            </div>

            <div class="pipeline-stage" id="stage-backbone">
                <div class="stage-header">
                    <div class="stage-name">🏗️ Backbone Network</div>
                    <div class="stage-progress">0%</div>
                </div>
                <div class="stage-description">Feature extraction using ResNet/EfficientNet</div>
                <div class="progress-bar">
                    <div class="progress-fill"></div>
                </div>
                <div class="layer-visualization">
                    <div class="layer-row">
                        <div class="layer-icon">🔲</div>
                        <div class="layer-info">
                            <div class="layer-name">Conv2D Layer</div>
                            <div class="layer-details">64 filters, 7x7 kernel</div>
                        </div>
                        <div class="layer-status status-waiting">Waiting</div>
                    </div>
                    <div class="layer-row">
                        <div class="layer-icon">📊</div>
                        <div class="layer-info">
                            <div class="layer-name">Batch Norm</div>
                            <div class="layer-details">Feature normalization</div>
                        </div>
                        <div class="layer-status status-waiting">Waiting</div>
                    </div>
                    <div class="layer-row">
                        <div class="layer-icon">🔥</div>
                        <div class="layer-info">
                            <div class="layer-name">ReLU Activation</div>
                            <div class="layer-details">Non-linear activation</div>
                        </div>
                        <div class="layer-status status-waiting">Waiting</div>
                    </div>
                </div>
            </div>

            <div class="pipeline-stage" id="stage-detection">
                <div class="stage-header">
                    <div class="stage-name">🎯 Object Detection</div>
                    <div class="stage-progress">0%</div>
                </div>
                <div class="stage-description">Building detection and segmentation</div>
                <div class="progress-bar">
                    <div class="progress-fill"></div>
                </div>
                <div class="layer-visualization">
                    <div class="layer-row">
                        <div class="layer-icon">📍</div>
                        <div class="layer-info">
                            <div class="layer-name">Region Proposal</div>
                            <div class="layer-details">RPN network</div>
                        </div>
                        <div class="layer-status status-waiting">Waiting</div>
                    </div>
                    <div class="layer-row">
                        <div class="layer-icon">🎭</div>
                        <div class="layer-info">
                            <div class="layer-name">Mask Head</div>
                            <div class="layer-details">Pixel-level segmentation</div>
                        </div>
                        <div class="layer-status status-waiting">Waiting</div>
                    </div>
                </div>
            </div>

            <div class="pipeline-stage" id="stage-postprocessing">
                <div class="stage-header">
                    <div class="stage-name">🏁 Post-processing</div>
                    <div class="stage-progress">0%</div>
                </div>
                <div class="stage-description">NMS, filtering, and regularization</div>
                <div class="progress-bar">
                    <div class="progress-fill"></div>
                </div>
                <div class="layer-visualization">
                    <div class="layer-row">
                        <div class="layer-icon">🧹</div>
                        <div class="layer-info">
                            <div class="layer-name">NMS Filter</div>
                            <div class="layer-details">Remove duplicates</div>
                        </div>
                        <div class="layer-status status-waiting">Waiting</div>
                    </div>
                    <div class="layer-row">
                        <div class="layer-icon">📐</div>
                        <div class="layer-info">
                            <div class="layer-name">Regularization</div>
                            <div class="layer-details">Shape optimization</div>
                        </div>
                        <div class="layer-status status-waiting">Waiting</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Neural Network Canvas -->
        <main class="neural-canvas" id="neural-canvas">
            <div class="neural-overlay">
                <div style="font-weight: 600; margin-bottom: 10px;">🧠 Neural Network Activity</div>
                <div>Active Neurons: <span id="active-neurons">0</span></div>
                <div>Forward Pass: <span id="forward-pass">Idle</span></div>
                <div>Gradient Flow: <span id="gradient-flow">Idle</span></div>
            </div>
        </main>

        <!-- Results Panel -->
        <aside class="results-panel scrollbar">
            <div class="panel-title">
                🏢 Detection Results
            </div>
            <div id="detection-results">
                <!-- Results will be populated here -->
            </div>
        </aside>

        <!-- Controls Panel -->
        <section class="controls-panel">
            <div class="panel-title">
                🎮 Controls
            </div>

            <div class="model-selector">
                <div class="model-option active" data-model="mask_rcnn">
                    Mask R-CNN
                </div>
                <div class="model-option" data-model="adaptive_fusion">
                    Adaptive Fusion
                </div>
                <div class="model-option" data-model="hybrid">
                    Hybrid Model
                </div>
            </div>

            <button class="control-button" onclick="startProcessing()">
                🚀 Start Processing
            </button>
            <button class="control-button secondary" onclick="pauseProcessing()">
                ⏸️ Pause Processing
            </button>
            <button class="control-button secondary" onclick="resetVisualization()">
                🔄 Reset Pipeline
            </button>
        </section>

        <!-- Metrics Panel -->
        <section class="metrics-panel">
            <div class="panel-title">
                📊 Performance Metrics
            </div>

            <div class="metric-item">
                <span>Throughput</span>
                <span class="metric-value" id="throughput-metric">0 img/s</span>
            </div>
            <div class="metric-item">
                <span>Latency</span>
                <span class="metric-value" id="latency-metric">0ms</span>
            </div>
            <div class="metric-item">
                <span>Memory Usage</span>
                <span class="metric-value" id="memory-metric">0 MB</span>
            </div>
            <div class="metric-item">
                <span>Batch Size</span>
                <span class="metric-value" id="batch-metric">1</span>
            </div>

            <div class="data-flow">
                <div class="flow-node">IN</div>
                <div class="flow-arrow">→</div>
                <div class="flow-node">CNN</div>
                <div class="flow-arrow">→</div>
                <div class="flow-node">OUT</div>
            </div>
        </section>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let neuralNetwork, dataParticles;
        let isProcessing = false;
        let currentModel = 'mask_rcnn';
        let websocket = null;
        
        // Configuration
        const API_BASE = 'http://127.0.0.1:8002';
        const WS_URL = 'ws://127.0.0.1:8002/ws';
        
        // Processing stages
        const stages = [
            'stage-input',
            'stage-preprocessing', 
            'stage-backbone',
            'stage-detection',
            'stage-postprocessing'
        ];
        
        let currentStage = 0;
        let stageProgress = 0;

        // Initialize visualization
        document.addEventListener('DOMContentLoaded', function() {
            initializeNeuralCanvas();
            setupEventListeners();
            connectWebSocket();
            startMetricsUpdate();
        });

        function initializeNeuralCanvas() {
            const container = document.getElementById('neural-canvas');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 50);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            
            // Create neural network visualization
            createNeuralNetwork();
            
            // Start animation
            animate();
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }

        function createNeuralNetwork() {
            neuralNetwork = new THREE.Group();
            
            // Create layers
            const layers = [
                { neurons: 784, position: -30, color: 0xff6b6b, name: 'Input' },
                { neurons: 512, position: -15, color: 0x4ecdc4, name: 'Conv1' },
                { neurons: 256, position: 0, color: 0x45b7d1, name: 'Conv2' },
                { neurons: 128, position: 15, color: 0xf39c12, name: 'Dense' },
                { neurons: 64, position: 30, color: 0x64ffda, name: 'Output' }
            ];
            
            layers.forEach((layer, layerIndex) => {
                const layerGroup = new THREE.Group();
                layerGroup.position.x = layer.position;
                
                // Create neurons
                for (let i = 0; i < Math.min(layer.neurons, 20); i++) {
                    const neuronGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                    const neuronMaterial = new THREE.MeshBasicMaterial({ 
                        color: layer.color,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const neuron = new THREE.Mesh(neuronGeometry, neuronMaterial);
                    const angle = (i / Math.min(layer.neurons, 20)) * Math.PI * 2;
                    const radius = Math.sqrt(layer.neurons) * 0.5;
                    
                    neuron.position.y = Math.sin(angle) * radius;
                    neuron.position.z = Math.cos(angle) * radius;
                    neuron.userData = { layer: layerIndex, neuron: i, active: false };
                    
                    layerGroup.add(neuron);
                    
                    // Add connections to next layer
                    if (layerIndex < layers.length - 1) {
                        const connectionMaterial = new THREE.LineBasicMaterial({ 
                            color: 0x444444,
                            transparent: true,
                            opacity: 0.2
                        });
                        
                        // Create some connections (not all to avoid clutter)
                        if (i % 3 === 0) {
                            const nextLayer = layers[layerIndex + 1];
                            const connectionGeometry = new THREE.BufferGeometry();
                            const points = [];
                            
                            points.push(neuron.position.clone());
                            points.push(new THREE.Vector3(
                                nextLayer.position,
                                Math.sin(Math.random() * Math.PI * 2) * Math.sqrt(nextLayer.neurons) * 0.5,
                                Math.cos(Math.random() * Math.PI * 2) * Math.sqrt(nextLayer.neurons) * 0.5
                            ));
                            
                            connectionGeometry.setFromPoints(points);
                            const connection = new THREE.Line(connectionGeometry, connectionMaterial);
                            neuralNetwork.add(connection);
                        }
                    }
                }
                
                neuralNetwork.add(layerGroup);
            });
            
            scene.add(neuralNetwork);
            
            // Create data particles
            createDataParticles();
        }

        function createDataParticles() {
            dataParticles = new THREE.Group();
            
            for (let i = 0; i < 50; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x64ffda,
                    transparent: true,
                    opacity: 0.8
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );
                
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1
                    )
                };
                
                dataParticles.add(particle);
            }
            
            scene.add(dataParticles);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Animate neural network
            if (neuralNetwork && isProcessing) {
                neuralNetwork.children.forEach((layer, layerIndex) => {
                    layer.children.forEach(neuron => {
                        if (neuron.userData) {
                            // Simulate neural activity
                            if (layerIndex === currentStage || Math.random() < 0.1) {
                                neuron.userData.active = true;
                                neuron.material.emissive.setHex(0x333333);
                                neuron.scale.setScalar(1.2 + Math.sin(Date.now() * 0.01) * 0.2);
                            } else {
                                neuron.userData.active = false;
                                neuron.material.emissive.setHex(0x000000);
                                neuron.scale.setScalar(1);
                            }
                        }
                    });
                });
            }
            
            // Animate data particles
            if (dataParticles && isProcessing) {
                dataParticles.children.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    
                    // Reset position if out of bounds
                    if (particle.position.length() > 50) {
                        particle.position.set(
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10
                        );
                    }
                });
            }
            
            controls.update();
            renderer.render(scene, camera);
            
            // Update neural activity display
            if (neuralNetwork) {
                let activeNeurons = 0;
                neuralNetwork.children.forEach(layer => {
                    layer.children.forEach(neuron => {
                        if (neuron.userData && neuron.userData.active) {
                            activeNeurons++;
                        }
                    });
                });
                document.getElementById('active-neurons').textContent = activeNeurons;
            }
        }

        function onWindowResize() {
            const container = document.getElementById('neural-canvas');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        async function startProcessing() {
            if (isProcessing) return;
            
            isProcessing = true;
            currentStage = 0;
            
            document.getElementById('forward-pass').textContent = 'Active';
            document.getElementById('gradient-flow').textContent = 'Computing';
            
            // Start ML processing job
            try {
                const response = await axios.post(`${API_BASE}/api/v1/ml-processing/extract-buildings`, {
                    image_url: 'https://example.com/neural-test.jpg',
                    model_type: currentModel,
                    apply_regularization: true
                });
                
                if (response.data.job_id) {
                    monitorProcessingJob(response.data.job_id);
                }
            } catch (error) {
                console.log('Starting demo processing');
                simulateProcessing();
            }
            
            // Simulate pipeline progression
            processPipelineStage(0);
        }

        function processPipelineStage(stageIndex) {
            if (!isProcessing || stageIndex >= stages.length) {
                completeProcessing();
                return;
            }
            
            currentStage = stageIndex;
            const stageId = stages[stageIndex];
            const stageElement = document.getElementById(stageId);
            
            // Activate current stage
            document.querySelectorAll('.pipeline-stage').forEach(stage => {
                stage.classList.remove('active');
            });
            stageElement.classList.add('active');
            
            // Animate progress
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += 2 + Math.random() * 8;
                progress = Math.min(progress, 100);
                
                // Update progress display
                const progressBar = stageElement.querySelector('.progress-fill');
                const progressText = stageElement.querySelector('.stage-progress');
                
                progressBar.style.width = `${progress}%`;
                progressText.textContent = `${Math.floor(progress)}%`;
                
                // Update layer status
                const layers = stageElement.querySelectorAll('.layer-status');
                layers.forEach((layer, index) => {
                    if (progress > (index + 1) * (100 / layers.length)) {
                        layer.textContent = 'Completed';
                        layer.className = 'layer-status status-completed';
                    } else if (progress > index * (100 / layers.length)) {
                        layer.textContent = 'Processing';
                        layer.className = 'layer-status status-processing';
                    }
                });
                
                if (progress >= 100) {
                    clearInterval(progressInterval);
                    setTimeout(() => processPipelineStage(stageIndex + 1), 500);
                }
            }, 100);
        }

        function completeProcessing() {
            isProcessing = false;
            currentStage = -1;
            
            document.getElementById('forward-pass').textContent = 'Complete';
            document.getElementById('gradient-flow').textContent = 'Idle';
            
            // Reset pipeline after delay
            setTimeout(resetVisualization, 3000);
            
            // Add detection results
            addDetectionResults();
        }

        function addDetectionResults() {
            const resultsContainer = document.getElementById('detection-results');
            const buildingCount = 8 + Math.floor(Math.random() * 12);
            
            for (let i = 0; i < buildingCount; i++) {
                const confidence = 0.7 + Math.random() * 0.3;
                const area = 100 + Math.random() * 500;
                
                const resultElement = document.createElement('div');
                resultElement.className = 'result-item';
                resultElement.innerHTML = `
                    <div class="result-header">
                        <div>Building ${i + 1}</div>
                        <div class="result-confidence">${(confidence * 100).toFixed(1)}%</div>
                    </div>
                    <div class="result-details">
                        Area: ${area.toFixed(0)}m² | Type: Residential
                    </div>
                `;
                
                resultsContainer.appendChild(resultElement);
                
                // Remove old results
                if (resultsContainer.children.length > 10) {
                    resultsContainer.removeChild(resultsContainer.firstChild);
                }
            }
        }

        function pauseProcessing() {
            isProcessing = false;
            document.getElementById('forward-pass').textContent = 'Paused';
            document.getElementById('gradient-flow').textContent = 'Paused';
        }

        function resetVisualization() {
            isProcessing = false;
            currentStage = -1;
            
            document.getElementById('forward-pass').textContent = 'Idle';
            document.getElementById('gradient-flow').textContent = 'Idle';
            
            // Reset all stages
            document.querySelectorAll('.pipeline-stage').forEach(stage => {
                stage.classList.remove('active');
                stage.querySelector('.progress-fill').style.width = '0%';
                stage.querySelector('.stage-progress').textContent = '0%';
                
                stage.querySelectorAll('.layer-status').forEach(status => {
                    status.textContent = 'Waiting';
                    status.className = 'layer-status status-waiting';
                });
            });
            
            // Clear results
            document.getElementById('detection-results').innerHTML = '';
        }

        function setupEventListeners() {
            // Model selector
            document.querySelectorAll('.model-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelector('.model-option.active').classList.remove('active');
                    this.classList.add('active');
                    currentModel = this.dataset.model;
                });
            });
        }

        function connectWebSocket() {
            try {
                websocket = new WebSocket(WS_URL);
                
                websocket.onopen = function() {
                    console.log('Processing visualization WebSocket connected');
                };
                
                websocket.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                };
                
                websocket.onclose = function() {
                    setTimeout(connectWebSocket, 5000);
                };
                
            } catch (error) {
                console.log('WebSocket not available');
            }
        }

        function handleWebSocketMessage(data) {
            switch (data.type) {
                case 'job_progress':
                    updateProcessingProgress(data.progress, data.stage);
                    break;
                    
                case 'job_completed':
                    if (data.results) {
                        addDetectionResults();
                    }
                    break;
            }
        }

        function startMetricsUpdate() {
            setInterval(() => {
                // Update metrics
                const throughput = isProcessing ? (0.5 + Math.random() * 1.5) : 0;
                const latency = isProcessing ? (800 + Math.random() * 400) : 0;
                const memory = 150 + Math.random() * 200;
                const gpu = isProcessing ? (60 + Math.random() * 35) : (10 + Math.random() * 20);
                
                document.getElementById('throughput-metric').textContent = throughput.toFixed(1) + ' img/s';
                document.getElementById('latency-metric').textContent = Math.floor(latency) + 'ms';
                document.getElementById('memory-metric').textContent = Math.floor(memory) + ' MB';
                document.getElementById('gpu-utilization').textContent = Math.floor(gpu) + '%';
                document.getElementById('inference-speed').textContent = Math.floor(latency) + 'ms';
                
                // Update queue
                const queue = isProcessing ? Math.floor(Math.random() * 5) : 0;
                document.getElementById('processing-queue').textContent = queue;
                
            }, 1000);
        }

        // Start demo
        setTimeout(() => {
            startProcessing();
        }, 2000);
    </script>
</body>
</html>